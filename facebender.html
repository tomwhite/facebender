<html>

  <head>
    <title>Facebender</title>
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.96/jsxgraphcore.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
  </head>

  <body>
	<div id="controls">
	  <p id="instruction">Resize image</p>
	  <button onclick="resizeDone()">Done</button>
    </div>
	<div id="box" style="width:1000px; height:1000px;"></div>
    <script type="text/javascript">
	var board = JXG.JSXGraph.initBoard("box", {
	    boundingbox: [0, 0, 500, 500],
	    keepAspectRatio: true,
	    showCopyright: false,
	    showNavigation: false,
	    axis: false
	});
	
	var points = [
	[[135,145],],
	[[190,145],],
	[[128,144], [133,149], [140,144], [135,141], [128,144], ],
	];
	
	var features = [
	"left pupil",
	"right pupil",
	"left iris",
	//"right iris",
	];
	
	var faceData = [];
	
	var f = 1;
	
	var offsetX = 250;
	
	function makeUpdater(feat) {
		return function() {
			for (var i = 0; i < faceData[feat].length; i++) {
				var normX = points[feat][i][0];
				var normY = points[feat][i][1];
				var faceX = faceData[feat][i].X();
				var faceY = faceData[feat][i].Y();
				this.dataX[i] = faceX + f*(faceX-normX) + offsetX;
				this.dataY[i] = faceY + f*(faceY-normY);
			}
		};
	};

	var image;
	var resizePoint;
	
	// draw the background image
	function drawImage(imgx, imgy, imgw, imgh, imageUrl, fixed, origin) {
	  if (imageUrl != null) {
	    if (imgw == 0) { // image hasn't been loaded before, so calculate its dimensions
	      $('body').append('<div id="init"><img id="spiralImage" src="' + imageUrl + '" /></div>');
	      $('#init').hide();
	      $('#spiralImage').bind("load",function() {
	          var imWidthPx = this.width;
	          var imHeightPx = this.height;
	          var widthPx = $('#box').width();
	          var heightPx = $('#box').height();
	          var boundingBox = board.getBoundingBox();
	          var minx = boundingBox[0];
	          var miny = boundingBox[1];
	          var maxx = boundingBox[2];
	          var maxy = boundingBox[3];
              var width = minx + (maxx - minx) * imWidthPx/widthPx;
              var height = miny + (maxy - miny) * imHeightPx/heightPx;
              resizePoint = board.create('point', [width, height], { size:10, opacity:0.3, name:"" });
	          image = board.create('image', [imageUrl,
	            [minx, function(){ return calculateAspectRatioFit(width, height, resizePoint).height; }],
	              [function(){ return calculateAspectRatioFit(width, height, resizePoint).width; }, function(){ return calculateAspectRatioFit(width, height, resizePoint).height; }] ], {fixed: fixed});
	      });
	    } else {
	      image = board.create('image', [imageUrl, origin || [imgx, imgy], [imgw, imgh] ], {fixed: fixed});
	    }
	  }  
	}
	
	function calculateAspectRatioFit(srcWidth, srcHeight, p) {
        var ratio = Math.min(p.X() / srcWidth, p.Y() / srcHeight);
        return { width: srcWidth*ratio, height: srcHeight*ratio };
	}
	
	function resizeDone() {
		board.removeObject(resizePoint);
		chooseNextFeature();
	}
	
	var featureIndex = 0;
	var subFeatureIndex = 0;
	var pointIndex = 0;
	var downEnabled = true;
	
	function chooseNextFeature() {
		if (featureIndex == 0) {
			// from http://jsxgraph.uni-bayreuth.de/wiki/index.php/Browser_event_and_coordinates
			var getMouseCoords = function(e, i) {
			        var cPos = board.getCoordsTopLeftCorner(e, i),
			            absPos = JXG.getPosition(e, i),
			            dx = absPos[0]-cPos[0],
			            dy = absPos[1]-cPos[1];

			        return new JXG.Coords(JXG.COORDS_BY_SCREEN, [dx, dy], board);
			    };
			var down = function(e) {
			        if (!downEnabled) return;
			        var canCreate = true, i, coords, el;

			        if (e[JXG.touchProperty]) {
			            // index of the finger that is used to extract the coordinates
			            i = 0;
			        }
			        coords = getMouseCoords(e, i);

			        for (el in board.objects) {
			            if(JXG.isPoint(board.objects[el]) && board.objects[el].hasPoint(coords.scrCoords[1], coords.scrCoords[2])) {
			                canCreate = false;
			                break;
			            }
			        }

			        if (canCreate) {
			        	// create a point on the image
			            board.create('point', [coords.usrCoords[1], coords.usrCoords[2]], {name: '', size: 1, face: 'o'});

						// hide the point on the average face
			            if (featureIndex > 1) {
  				            faceData[featureIndex][subFeatureIndex].setProperty({visible:false});
			            }

			            var subFeatureCount = points[featureIndex].length;
			            if (++subFeatureIndex == subFeatureCount) {
				            featureIndex++;
				            subFeatureIndex = 0;
			            }
			            pointIndex++;
			            if (featureIndex == 2 && subFeatureIndex == 0) {
			            	showAverageFace();
			            }
						// show the next point on the average face
			            if (featureIndex > 1 && featureIndex < features.length) {
  				            faceData[featureIndex][subFeatureIndex].setProperty({visible:true});
			            }
			            if (featureIndex < features.length) {
				            chooseNextFeature();
						} else {
							downEnabled = false;
							bendFace();
						}
			        }
			    };

			handlerId = board.on('down', down);
		}
		$('#controls').html('<p id="instruction">Choose ' + features[featureIndex] + ' (' + (subFeatureIndex + 1) + ' of ' + points[featureIndex].length + ')</p>');
	}

	function showAverageFace() {
		// TODO: transform so that face has eyes same distance apart, level with photo, and to the right of photo
		var translation = board.create('transform', [200, 0], {type:'translate'});
		for (var feature = 0; feature < points.length; feature++) {
			var featurePoints = points[feature];
			var p = [];
			var x = [];
			var y = [];
			// TODO: make eyes fixed so you can't move them
			for (var i = 0; i < featurePoints.length; i++) {
				p[i] = board.create('point', featurePoints[i], {name: '', size: 1, face: 'o', visible: false});
				translation.bindTo(p[i]);
				//x[i] = featurePoints[i][0] + offsetX;
				//y[i] = featurePoints[i][1];
			}
			faceData[feature] = p;
			// TODO: create point for features of length 1 (pupils)
			for (var i = 1; i < p.length; i++) {
				board.create('segment', [p[i-1], p[i]]);
			}
//			var c = board.create('curve', [x, y]);
//			c.updateDataArray = makeUpdater(feature);
		}
	}

	function bendFace() {
	}

	// TODO: open an image and allow it to be moved around (like spirals)
	var imageUrl = "file:///Users/tom/projects-workspace/facebender/images/tom.jpg"
	drawImage(0, 0, 0, 0, imageUrl, true, [0, 0]); 
	
	// TODO: give each point a name
	
	// TODO: save image
		
    </script>
  </body>

</html>
